const { getPgPool } = require('../config/db');
const { v4: uuidv4 } = require('uuid');

/**
 * Invoice Model - Clean implementation matching database schema
 */
class Invoice {
    /**
     * Generate invoice number
     */
    static generateNumber() {
        const date = new Date();
        const prefix = `INV${date.getFullYear()}${String(date.getMonth() + 1).padStart(2, '0')}`;
        const suffix = Math.random().toString(36).substring(2, 8).toUpperCase();
        return `${prefix}-${suffix}`;
    }

    /**
     * Find invoice by ID
     */
    static async findById(id) {
        const pool = getPgPool();
        const query = `
            SELECT i.*, b.booking_reference, b.customer_email, b.customer_first_name, b.customer_last_name,
                   e.title as event_title, e.event_date, e.venue_name
            FROM invoices i
            JOIN bookings b ON i.booking_id = b.id
            JOIN events e ON b.event_id = e.id
            WHERE i.id = $1
        `;
        const result = await pool.query(query, [id]);
        return result.rows[0] ? this.format(result.rows[0]) : null;
    }

    /**
     * Find invoice by number
     */
    static async findByNumber(invoiceNumber) {
        const pool = getPgPool();
        const query = `
            SELECT i.*, b.booking_reference, b.customer_email, b.customer_first_name, b.customer_last_name,
                   e.title as event_title, e.event_date, e.venue_name
            FROM invoices i
            JOIN bookings b ON i.booking_id = b.id
            JOIN events e ON b.event_id = e.id
            WHERE i.invoice_number = $1
        `;
        const result = await pool.query(query, [invoiceNumber]);
        return result.rows[0] ? this.format(result.rows[0]) : null;
    }

    /**
     * Find invoices by user
     */
    static async findByUserId(userId, options = {}) {
        const pool = getPgPool();
        const { limit = 20, offset = 0 } = options;
        
        const query = `
            SELECT i.*, b.booking_reference, e.title as event_title, e.event_date
            FROM invoices i
            JOIN bookings b ON i.booking_id = b.id
            JOIN events e ON b.event_id = e.id
            WHERE i.user_id = $1
            ORDER BY i.created_at DESC
            LIMIT $2 OFFSET $3
        `;
        const result = await pool.query(query, [userId, limit, offset]);
        return result.rows.map(this.format);
    }

    /**
     * Find invoice by booking
     */
    static async findByBookingId(bookingId) {
        const pool = getPgPool();
        const query = `SELECT * FROM invoices WHERE booking_id = $1`;
        const result = await pool.query(query, [bookingId]);
        return result.rows[0] ? this.format(result.rows[0]) : null;
    }

    /**
     * Create invoice
     * Database columns: id, invoice_number, booking_id, user_id, invoice_date, due_date, 
     *                   amount, tax_amount, currency, status, line_items, payment_reference, payment_notes
     */
    static async create(data) {
        const pool = getPgPool();
        const id = uuidv4();
        // Note: invoice_number is auto-generated by database trigger
        const taxAmount = parseFloat(data.taxAmount || 0);
        const amount = parseFloat(data.amount || 0);

        // Build line_items array
        const lineItems = data.lineItems || data.seats?.map(s => ({
            description: s.seatLabel || `Seat ${s.id}`,
            quantity: 1,
            unitPrice: parseFloat(s.price || 0),
            total: parseFloat(s.price || 0)
        })) || [{ description: 'Event Ticket', quantity: 1, unitPrice: amount, total: amount }];

        const query = `
            INSERT INTO invoices (
                id, booking_id, user_id, amount, tax_amount, currency, status, line_items
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            RETURNING *
        `;

        const values = [
            id, data.bookingId, data.userId || null,
            amount, taxAmount, data.currency || 'INR', 'issued', JSON.stringify(lineItems)
        ];

        const result = await pool.query(query, values);
        return this.format(result.rows[0]);
    }

    /**
     * Mark invoice as paid
     */
    static async markPaid(id) {
        const pool = getPgPool();
        const query = `
            UPDATE invoices SET status = 'paid', paid_at = NOW()
            WHERE id = $1 RETURNING *
        `;
        const result = await pool.query(query, [id]);
        return result.rows[0] ? this.format(result.rows[0]) : null;
    }

    /**
     * Format invoice for API response
     */
    static format(invoice) {
        if (!invoice) return null;
        const amount = parseFloat(invoice.amount) || 0;
        const taxAmount = parseFloat(invoice.tax_amount) || 0;
        return {
            id: invoice.id,
            invoiceNumber: invoice.invoice_number,
            bookingId: invoice.booking_id,
            bookingReference: invoice.booking_reference,
            userId: invoice.user_id,
            event: invoice.event_title ? {
                title: invoice.event_title,
                eventDate: invoice.event_date,
                venueName: invoice.venue_name
            } : null,
            customer: invoice.customer_email ? {
                email: invoice.customer_email,
                firstName: invoice.customer_first_name,
                lastName: invoice.customer_last_name
            } : null,
            amount: amount,
            taxAmount: taxAmount,
            totalAmount: amount + taxAmount, // Calculated, not stored
            currency: invoice.currency,
            status: invoice.status,
            invoiceDate: invoice.invoice_date,
            dueDate: invoice.due_date,
            paidAt: invoice.paid_at,
            lineItems: invoice.line_items,
            paymentReference: invoice.payment_reference,
            pdfPath: invoice.pdf_path,
            createdAt: invoice.created_at,
            updatedAt: invoice.updated_at
        };
    }
}

module.exports = Invoice;
